<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Data Science em Gestão de Negócios e Finanças</title>
    <meta charset="utf-8" />
    <meta name="author" content="Arthur Welle" />
    <script src="libs/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="custom.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, top, title-slide

# Data Science em Gestão de Negócios e Finanças
## <br>Introdução ao Tidyverse 1
### Arthur Welle
### 21 jun, 2021

---




# Índice

1. Dividindo e selecionado dados

2. Criando Variáveis

3. Agregando dados

4. Tidying dados

5. Juntando diferentes bases de dados

6. Material adicional

---
class: inverse

# O que será necessário hoje

---
# Pacotes

Esta apresentação está baseada inteiramente nos pacotes do [`tidyverse`](https://www.tidyverse.org/).

--

O `tidyverse` é uma coleção de pacotes de R que compatilham o mesmo design, a mesma sintaxe, e a mesma estrutura.

--

No `tidyverse` se incluem os pacotes mais utilizados no mundo do R: [`dplyr`](https://dplyr.tidyverse.org/) para manipular os dados e [`ggplot2`](https://ggplot2.tidyverse.org/) para visualizar os resultados.

--

Você pode instalar *todos* os pacotes do `tidyverse` de uma vez usando o seguinte comando:


```r
install.packages("tidyverse")
```

--

Usaremos também os pacotes `gapminder` e `nycflights13` que são pacotes contendo dados para alguns de nossos exercícios:


```r
install.packages("gapminder")
install.packages("nycflights13")
```

---
# gapminder

Inspecionar o banco de dados gapminder. Quais são suas variáveis?

`head(gapminder)` mostra as primeiras linhas

`colnames(gapminder)` mostra o nome das colunas do objeto gapminder

`glimpse(gapminder)` outra maneira de nos dar uma amostra das variáveis presentes no objeto

`view(gapminder)` abre o banco de dados para inspeção (cuidado ao fazer isso com grandes bancos de dados)



```r
glimpse(gapminder)
```

```
## Rows: 1,704
## Columns: 6
## $ country   &lt;fct&gt; "Afghanistan", "Afghanistan", "Afghanistan", "Afghanistan", …
## $ continent &lt;fct&gt; Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, Asia, …
## $ year      &lt;int&gt; 1952, 1957, 1962, 1967, 1972, 1977, 1982, 1987, 1992, 1997, …
## $ lifeExp   &lt;dbl&gt; 28.801, 30.332, 31.997, 34.020, 36.088, 38.438, 39.854, 40.8…
## $ pop       &lt;int&gt; 8425333, 9240934, 10267083, 11537966, 13079460, 14880372, 12…
## $ gdpPercap &lt;dbl&gt; 779.4453, 820.8530, 853.1007, 836.1971, 739.9811, 786.1134, …
```

---
class: inverse

# Pipes `%&gt;%`


---
# Pipes `%&gt;%` 

O `Tidyverse` (e muitos outros pacotes) usam o operador **pipe** (**`%&gt;%`**) advindo do pacote  [`magrittr`](https://cran.r-project.org/web/packages/magrittr/vignettes/magrittr.html). 

--

Desde maio de 2021 na versão [`4.1.0`](https://cran.r-project.org/bin/windows/base/NEWS.R-4.1.0.html ) do R  pipe foi implementado no R base, com na forma `|&gt;`, mas como ele tem diferenças para o anterior vamos, por enquanto, preferir `%&gt;%`.

--

O atalho para o `%&gt;%` é `Ctrl+Shift+M` ou `⌘ +Shift+M` no Mac.

--

Pipes pegam os objetos a *esquerda* e aplicam è eles uma função à *direita*: `x %&gt;% f() `. Lê-se "pegue x e então aplique a função f() neste objeto". A tradução lógica para pipe seria "e então..." 

---
# Pipes `%&gt;%`

Os pipes nos ajudam a fazer o código ser mais legível pois seguem a sequência de passos que intuitivamente esperamos usar para transformar os dados.

--

Com o pipe você pode reescrever isso:


```r
corta(assa(mistura(compra(lista_ingredientes))))
```

desta maneira:


```r
lista_ingredientes %&gt;% 
    compra() %&gt;% 
    mistura() %&gt;% 
    assa() %&gt;% 
    corta()
```

São logicamente equivalentes mas com o pipe a ordem de leitura segue a ordem cognitiva.
---

Exemplo abaixo:

  1) crie objeto com 100 números aleatórios **e então...**
  
  2) cria a densidade de probabilidade **e então...**
  
  3) plota no gráfico o resultado.
  

```r
rnorm(100) %&gt;% 
  density() %&gt;% 
  plot() 
```

![](Aula2_Tidyverse_files/figure-html/unnamed-chunk-6-1.png)&lt;!-- --&gt;


---
Outro exemplo:

  1) Pegue objeto "gapminder", **e então...**
  
  2) Selecione somente o Canadá, **e então...**
  
  3) Mostre os dois primeiros casos.


```r
library(dplyr)
library(gapminder)

gapminder %&gt;% 
  filter(country == "Canada") %&gt;%  
  head(2)
```

```
## # A tibble: 2 x 6
##   country continent  year lifeExp      pop gdpPercap
##   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
## 1 Canada  Americas   1952    68.8 14785584    11367.
## 2 Canada  Americas   1957    70.0 17010154    12490.
```

---

# Criando um objeto com o pipe

Quando queremos criar um novo objeto com o resultado de uma corrente de pipes podemos usar o operador `&lt;-` no início da corrente, ou `-&gt;` no fim da corrente. Abaixo duas formas de criar o objeto chamado **"fatia"** com o resultado da cadeia de ações ou funções.


```r
fatia &lt;- lista_ingredientes %&gt;% 
    compra() %&gt;% 
    mistura() %&gt;% 
    assa() %&gt;% 
    corta()
```

ou


```r
lista_ingredientes %&gt;% 
    compra() %&gt;% 
    mistura() %&gt;% 
    assa() %&gt;% 
    corta() -&gt; fatia
```

---

# Usando Pipes

O resultado da função aplicada é passada para o *primeiro argumento* da função que vem a seguir. 

--

Caso hava necessidade de passar o resultado do fluxo de pipes para outro argumento que não o primeio basta usar o `.` que serve como marcador para o resultado anterior. Podemos fazer isso também se nomearmos os argumentos que a função usa.


```r
fatia &lt;- lista_ingredientes %&gt;% 
    compra(onde = "supermercado", oque = .) %&gt;% 
    mistura(ferramenta = "colher", conteudo = .) %&gt;% 
    assa(onde = "forno", oque = ., temperatura = 90) %&gt;% 
    corta(tamanho = 2, oque = .)
```

.footnote[Note que o novo pipe nativo `|&gt;` ainda não utiliza o marcador `.`.]

---
# Pipes `%&gt;%`

Pipes são ótimos para tornar o código claro e legível. 

--

No entanto, ele não é recomendado uso quando o fluxo de passos não é linear, ou quando estamos gerando multiplos objetos.

---
class: inverse

# Manipulação de dados 

---

# Os quatro principais "verbos" do dplyr:

### `filter()` 

### `select()` 

### `mutate()`

### `summarize()`

uma "preposição":

### `group_by()`

.smaller[ e outros verbos como `arrange()`, `rename()`]
---

# `filter` Data Frames

**`filter()`** é usado para selecionar um conjunto de **linhas** dentro do banco de dados que satisfazem as condições lógicas dentro da função `filter()`.


```r
gapminder %&gt;% 
  filter(country == "Oman") %&gt;% 
  head(8)
```

```
## # A tibble: 8 x 6
##   country continent  year lifeExp     pop gdpPercap
##   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;
## 1 Oman    Asia       1952    37.6  507833     1828.
## 2 Oman    Asia       1957    40.1  561977     2243.
## 3 Oman    Asia       1962    43.2  628164     2925.
## 4 Oman    Asia       1967    47.0  714775     4721.
## 5 Oman    Asia       1972    52.1  829050    10618.
## 6 Oman    Asia       1977    57.4 1004533    11848.
## 7 Oman    Asia       1982    62.7 1301048    12955.
## 8 Oman    Asia       1987    67.7 1593882    18115.
```

O que isto está fazendo?

---

# Revisão de operadores lógicos

Operadores lógicos retornam *verdadeiro* (`TRUE`), *falso* (`FALSE`), ou *não disponível* `NA`.

--

`filter()` retorna os valores que atendem a condição, portanto verdadeiros (`TRUE`).

Usamos `==` para testes de igualdade: `country == "Oman"`.

--

Outros [operadores lógicos](http://www.statmethods.net/management/operators.html):

--

* `!=`: não igual a
--

* `&gt;`, `&gt;=`, `&lt;`, `&lt;=`: menor que, menor ou igual que, maior que, maior ou igual
--

* `%in%`: checa se é igual a pelo menos um elemento de um conjunto

--

Operadores usados para combinar outros 

* `&amp;`: ambas as condições tem que ser verdadeiras (**E**)
--

* `|`: pelo menos uma das condições tem que ser verdadeira (**OU**)
--

* `!`: negação; inverte o valor do elemento (`TRUE` se torna `FALSE`, `FALSE` se torna `TRUE`)

---

# Exemplo de multiplas condições

Vamos filtrar a base para manter somente Oman entre 1980 e 2000.

--


```r
gapminder %&gt;%
    filter(country == "Oman" &amp;
           year &gt; 1980 &amp;
           year &lt;= 2000 )
```

```
## # A tibble: 4 x 6
##   country continent  year lifeExp     pop gdpPercap
##   &lt;fct&gt;   &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;   &lt;int&gt;     &lt;dbl&gt;
## 1 Oman    Asia       1982    62.7 1301048    12955.
## 2 Oman    Asia       1987    67.7 1593882    18115.
## 3 Oman    Asia       1992    71.2 1915208    18617.
## 4 Oman    Asia       1997    72.5 2283635    19702.
```

---
# `%in%` exemplo de uso

Filtrar linhas que tenham algo em comum com qualquer elemento de um conjunto de elementos.


```r
# criando objeto lista de membros fundadores do Mercosul
lista_paises_Mercosul &lt;- c(
            "Brazil", 
            "Argentina",
            "Paraguai",
            "Uruguay") 

# cria nova base com países que estão na lista acima
mercosul &lt;- gapminder %&gt;%
  filter(country %in% lista_paises_Mercosul)

# mostra resultado
mercosul
```

```
## # A tibble: 36 x 6
##    country   continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Argentina Americas   1952    62.5 17876956     5911.
##  2 Argentina Americas   1957    64.4 19610538     6857.
##  3 Argentina Americas   1962    65.1 21283783     7133.
##  4 Argentina Americas   1967    65.6 22934225     8053.
##  5 Argentina Americas   1972    67.1 24779799     9443.
##  6 Argentina Americas   1977    68.5 26983828    10079.
##  7 Argentina Americas   1982    69.9 29341374     8998.
##  8 Argentina Americas   1987    70.8 31620918     9140.
##  9 Argentina Americas   1992    71.9 33958947     9308.
## 10 Argentina Americas   1997    73.3 36203463    10967.
## # … with 26 more rows
```


---
## Ordenando: `arrange()`

podemo ordenar os resultados usando `arrange()`


```r
mercosul %&gt;% 
  arrange(year, -pop)
```

```
## # A tibble: 36 x 6
##    country   continent  year lifeExp      pop gdpPercap
##    &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt;
##  1 Brazil    Americas   1952    50.9 56602560     2109.
##  2 Argentina Americas   1952    62.5 17876956     5911.
##  3 Uruguay   Americas   1952    66.1  2252965     5717.
##  4 Brazil    Americas   1957    53.3 65551171     2487.
##  5 Argentina Americas   1957    64.4 19610538     6857.
##  6 Uruguay   Americas   1957    67.0  2424959     6151.
##  7 Brazil    Americas   1962    55.7 76039390     3337.
##  8 Argentina Americas   1962    65.1 21283783     7133.
##  9 Uruguay   Americas   1962    68.3  2598466     5603.
## 10 Brazil    Americas   1967    57.6 88049823     3430.
## # … with 26 more rows
```

Ordenados ascendentemente por `year` e descendentemente por `pop`.

---
## Selecionando colunas: `select()`

Além de filtrar linhas podemo selecionar as colunas de interesse usando **`select()`**. 


```r
mercosul %&gt;% 
  select(country, year, pop) %&gt;% 
  head(4)
```

```
## # A tibble: 4 x 3
##   country    year      pop
##   &lt;fct&gt;     &lt;int&gt;    &lt;int&gt;
## 1 Argentina  1952 17876956
## 2 Argentina  1957 19610538
## 3 Argentina  1962 21283783
## 4 Argentina  1967 22934225
```

Note que a ordem das colunas também mudou, seguindo a ordem passada para `select()`.
---
## Removendo colunas: `select()`


Podemos remover as colunas de interesse usando o sinal de menos (`-`) dentro do `select()`. 


```r
mercosul %&gt;% 
  select(-continent, -pop, -lifeExp) %&gt;% 
  head(4)
```

```
## # A tibble: 4 x 3
##   country    year gdpPercap
##   &lt;fct&gt;     &lt;int&gt;     &lt;dbl&gt;
## 1 Argentina  1952     5911.
## 2 Argentina  1957     6857.
## 3 Argentina  1962     7133.
## 4 Argentina  1967     8053.
```

---
## Funções auxiliares para `select()`


`select()` tem um conjunto de funções auxiliares `starts_with()`, `ends_with()`, e `contains()`, ou ainda podemo usar um intervalo entre duas variáveis/colunas escolhidas `coluna1:coluna4`. Veja detalhes na ajuda da função usando `?select`.

Estas funções auxiliares são particularmente interessantes quando temos um banco de dados com muitas variáveis, ou variáveis com nomes parecidos. 



```r
mercosul %&gt;%  
  select(starts_with("gdp")) %&gt;% 
  head(4)
```

```
## # A tibble: 4 x 1
##   gdpPercap
##       &lt;dbl&gt;
## 1     5911.
## 2     6857.
## 3     7133.
## 4     8053.
```

---
## Renomeando colunas com `select()`


Podemos renomear as coluans usando `select()`, mas lembre-se que toda colunas não mencionado será removida.


```r
mercosul %&gt;%
    select(Life_Expectancy = lifeExp) %&gt;%
    head(4)
```

```
## # A tibble: 4 x 1
##   Life_Expectancy
##             &lt;dbl&gt;
## 1            62.5
## 2            64.4
## 3            65.1
## 4            65.6
```

---
### Renomeando colunas com `rename()`


**`rename()`** renomeia colunas com a mesma sintaxe que `select()` sem remover colunas não mencionadas.


```r
mercosul %&gt;%
    select(country, year, lifeExp) %&gt;%
    rename(Life_Expectancy = lifeExp) %&gt;%
    head(4)
```

```
## # A tibble: 4 x 3
##   country    year Life_Expectancy
##   &lt;fct&gt;     &lt;int&gt;           &lt;dbl&gt;
## 1 Argentina  1952            62.5
## 2 Argentina  1957            64.4
## 3 Argentina  1962            65.1
## 4 Argentina  1967            65.6
```

---
class: inverse
# Criando variáveis

---
## `mutate()`

No `dplyr`, você pode criar novas colunas/variáveis usando a função **`mutate()`**.



```r
mercosul %&gt;% filter(country == "Brazil") %&gt;%
    select(-continent, -lifeExp) %&gt;%
    mutate(pop_million = pop / 1000000,
           GDP = gdpPercap * pop) %&gt;% 
    head(5)
```

```
## # A tibble: 5 x 6
##   country  year       pop gdpPercap pop_million           GDP
##   &lt;fct&gt;   &lt;int&gt;     &lt;int&gt;     &lt;dbl&gt;       &lt;dbl&gt;         &lt;dbl&gt;
## 1 Brazil   1952  56602560     2109.        56.6 119371649391.
## 2 Brazil   1957  65551171     2487.        65.6 163049753285.
## 3 Brazil   1962  76039390     3337.        76.0 253711949067.
## 4 Brazil   1967  88049823     3430.        88.0 301998949548.
## 5 Brazil   1972 100840058     4986.       101.  502759433504.
```

.footnote[Veja que podemos criar mais de uma variável no mesmo `mutate()` separando cada uma por uma vírgula.]

---
# `ifelse()`


Uma função comum usada dentro do`mutate()` é o **`ifelse()`**. Ele retorna um vetor de resultados baseado no resultado de um teste.


```r
x &lt;- 1
y &lt;- 2
ifelse(test = x==y, yes = "Verdadeiro" , no = "Falso")
```

```
## [1] "Falso"
```

Como em boa parte das funções se você entregar um vetor de valores ao `ifelse()` ele retorna também um vetor de resultados.  
--

Exemplo:


```r
vetor_valores &lt;- c(1, 0, NA, -2)
ifelse(vetor_valores &gt; 0, "Positivo", "Negativo")
```

```
## [1] "Positivo" "Negativo" NA         "Negativo"
```

Veja que o teste para `NA` retorna `NA`.

---
# `ifelse()` 



```r
mercosul %&gt;% 
  mutate(apelido = ifelse(country == "Argentina",     # teste
                          "Hermanos",                 # se verdadeiro
                          as.character(country))) %&gt;% # se falso
  select(country, apelido, year, pop) %&gt;%
  arrange(year, apelido) %&gt;%
  head(3)
```

```
## # A tibble: 3 x 4
##   country   apelido   year      pop
##   &lt;fct&gt;     &lt;chr&gt;    &lt;int&gt;    &lt;int&gt;
## 1 Brazil    Brazil    1952 56602560
## 2 Argentina Hermanos  1952 17876956
## 3 Uruguay   Uruguay   1952  2252965
```

Em português leia-se "para cada linha, se o país é igual à "Argentina" então faça a nova variável `apelido` ganhar o texto "**Hermanos**", caso contrário o valor da variável `country`. É uma maneira fácil de mudar alguns valores e não outros.

---
# `case_when()`

**`case_when()`** faz multiplas operações `ifelse()` ao mesmo tempo. `case_when()` permite criar uma nova variável baseado em critérios de outras variáveis.
.smallish[

```r
mercosul %&gt;% 
  mutate(PIB_ranking = 
    case_when(
      gdpPercap &lt;  5000 ~ "baixo",
      gdpPercap &gt;= 5000 &amp; gdpPercap &lt; 7000 ~ "medio",
      TRUE ~ "alto" )) %&gt;% # se todos os outros casos forem falso
  head(4)
```

```
## # A tibble: 4 x 7
##   country   continent  year lifeExp      pop gdpPercap PIB_ranking
##   &lt;fct&gt;     &lt;fct&gt;     &lt;int&gt;   &lt;dbl&gt;    &lt;int&gt;     &lt;dbl&gt; &lt;chr&gt;      
## 1 Argentina Americas   1952    62.5 17876956     5911. medio      
## 2 Argentina Americas   1957    64.4 19610538     6857. medio      
## 3 Argentina Americas   1962    65.1 21283783     7133. alto       
## 4 Argentina Americas   1967    65.6 22934225     8053. alto
```
]

---
class: inverse

# Sumarizando dados

---
## Agregando dados com `summarize()`

**`summarize()`** recebe uma ou mais colunas dos seus dados e computa algo usando todas as linhas exemplos: 

* contar quantas linhas tem o banco de dados
* calcular a média 
* Computar a soma total dos valores de uma coluna
* Obter mínimo ou máximo valor

Você pode usar qualquer função dentro de `summarize()` que transforme **multiplos valores** em um **único valor** (como `sd()`, `mean()`, ou `max()`).


---
# `summarize()` exemplo

Para o ano de 2010, vamos calcular o *número de observações*, *população total*, *média expectativa de vida*, and *intervalo da expectativa de vida* dos países do Mercosul.


```r
mercosul %&gt;%
    filter(year == 2007) %&gt;%
    summarize(n_obs = n(),
              total_pop = sum(pop),
              med_exp_vida = mean(lifeExp),
              intervalo_exp_vida = max(lifeExp) - min(lifeExp))
```

```
## # A tibble: 1 x 4
##   n_obs total_pop med_exp_vida intervalo_exp_vida
##   &lt;int&gt;     &lt;int&gt;        &lt;dbl&gt;              &lt;dbl&gt;
## 1     3 233760070         74.7               3.99
```

As novas variáveis criadas como resultado usaram *todas as linhas* dos dados de `mercosul`.

---
# Avoiding Repetition: 

### `summarize_at()`


Maybe you need to calculate the mean and standard deviation of a bunch of columns. With **`summarize_at()`**, put the variables to compute over first `vars()` (using `select()` syntax) and put the functions to use in `funs()` after.


```r
mercosul %&gt;%
    filter(year == 1982) %&gt;%
    summarize_at(vars(lifeExp, pop), list(~mean(.), ~sd(.)))
```

```
## # A tibble: 1 x 4
##   lifeExp_mean pop_mean lifeExp_sd    pop_sd
##          &lt;dbl&gt;    &lt;dbl&gt;      &lt;dbl&gt;     &lt;dbl&gt;
## 1         68.0 53752770       4.09 66456757.
```

Note it automatically names the summarized variables based on the functions used to summarize.

---
# Avoiding Repetition

### Other functions:


There are additional `dplyr` functions similar to `summarize_at()`:

* `summarize_all()` and `mutate_all()` summarize / mutate *all* variables sent to them in the same way. For instance, getting the mean and standard deviation of an entire dataframe:


```r
dataframe %&gt;% summarize_all(funs(mean, sd))
```

* `summarize_if()` and `mutate_if()` summarize / mutate all variables that satisfy some logical condition. For instance, summarizing every numeric column in a dataframe at once:


```r
dataframe %&gt;% summarize_if(is.numeric, funs(mean, sd))
```

You can use all of these to avoid typing out the same code repeatedly!

---
# `group_by()`


The special function **`group_by()`** changes how subsequent functions operate on the data, most importantly `summarize()`.

Functions after `group_by()` are computed *within each group* as defined by unique valus of the variables given, rather than over all rows at once.

Typically the variables you group by will be integers, factors, or characters, and *not continuous real values*.

---
`group_by()` example



```r
mercosul %&gt;%
* group_by(year) %&gt;%
    summarize(num_countries = n_distinct(country),
              total_pop = sum(pop),
              total_gdp_per_cap = sum(pop*gdpPercap)/total_pop) %&gt;%
    head(5)
```

```
## # A tibble: 5 x 4
##    year num_countries total_pop total_gdp_per_cap
##   &lt;int&gt;         &lt;int&gt;     &lt;int&gt;             &lt;dbl&gt;
## 1  1952             3  76732481             3101.
## 2  1957             3  87586668             3567.
## 3  1962             3  99921639             4204.
## 4  1967             3 113732627             4411.
## 5  1972             3 128449383             5861.
```

Because we did `group_by()` with `year` then used `summarize()`, we get *one row per value of `year`*!

Each value of year is its own **group**!

---
## Window Functions

Grouping can also be used with `mutate()` or `filter()` to give rank orders within a group, lagged values, and cumulative sums. You can read more about window functions in this [vignette](https://cran.r-project.org/web/packages/dplyr/vignettes/window-functions.html).


```r
mercosul %&gt;% 
  select(country, year, pop) %&gt;%
  filter(year &gt;= 2002) %&gt;% 
  group_by(country) %&gt;%
  mutate(lag_pop = lag(pop, order_by = year),
         pop_chg = pop - lag_pop) %&gt;%
  head(4)
```

```
## # A tibble: 4 x 5
## # Groups:   country [2]
##   country    year       pop   lag_pop  pop_chg
##   &lt;fct&gt;     &lt;int&gt;     &lt;int&gt;     &lt;int&gt;    &lt;int&gt;
## 1 Argentina  2002  38331121        NA       NA
## 2 Argentina  2007  40301927  38331121  1970806
## 3 Brazil     2002 179914212        NA       NA
## 4 Brazil     2007 190010647 179914212 10096435
```


---
class: inverse
# Tidying Data

---
# Initial Spot Checks

.smallish[
First things to check after loading new data:
]
--

.smallish[
* Did the last rows/columns from the original file make it in?

    + May need to use different package or manually specify range
]
--

.smallish[
* Are the column names in good shape?

    + Modify a `col_names=` argument or fix with `rename()`
]
--
.smallish[

* Are there "decorative" blank rows or columns to remove?

    + `filter()` or `select()` out those rows/columns
]
--
.smallish[

* How are missing values represented: `NA`, `" "` (blank), `.` (period), `999`?

    + Use `mutate()` with `ifelse()` to fix these (perhaps *en masse* with looping)
]
--
.smallish[

* Are there character data (e.g. ZIP codes with leading zeroes) being incorrectly represented as numeric or vice versa?

    + Modify `col_types=` argument, or use `mutate()` and `as.numeric()`
]

---
# Slightly Messy Data

| **Program**     | **Female** | **Male** |
|-----------------|-----------:|---------:|
| Evans School    |     10     |    6    |
| Arts &amp; Sciences |      5     |    6    |
| Public Health   |      2     |    3    |
| Other           |      5     |    1    |

--

* What is an observation?
    + A group of students from a program of a given gender
* What are the variables?
    + Program, Gender, Count
* What are the values?
    + Program: Evans School, Arts &amp; Sciences, Public Health, Other
    + Gender: Female, Male -- **in the column headings, not its own column!**
    + Count: **spread over two columns!**

---
# Tidy Version

| **Program**     | **Gender** | **Count** |
|-----------------|-----------:|---------:|
| Evans School    |     Female |    10   |
| Evans School    |     Male   |    6    |
| Arts &amp; Sciences |     Female |    5    |
| Arts &amp; Sciences |     Male   |    6    |
| Public Health   |     Female |    2    |
| Public Health   |     Male   |    3    |
| Other           |     Female |    5    |
| Other           |     Male   |    1    |

Each variable is a column.

Each observation is a row.

Ready to throw into `ggplot()` or a model!


Data comes in many formats but R prefers just one: _tidy data_.

A data set is tidy if and only if:

1. Every variable is in its own column
2. Every observation is in its own row
3. Every value is in its own cell (which follows from the above)

What is a variable and an observation may depend on your immediate goal.



---
# Billboard Data

We're going to work with some *ugly* data: *The Billboard Hot 100 for the year 2000*.

We can load it like so:


```r
library(readr) # Contains read_csv()
billboard_2000_raw &lt;- 
  read_csv(file = "https://github.com/clanfear/Intermediate_R_Workshop/raw/master/data/billboard.csv",
*          col_types = paste(c("icccD", rep("i", 76)), collapse=""))
```

.footnote[`col_types=` is used to specify column types. [See here for details.](https://clanfear.github.io/CSSS508/Lectures/Week5/CSSS508_week5_data_import_export_cleaning.html#29)]

---
# Billboard is Just Ugly-Messy

.small[

| year |       artist        |          track          | time | date.entered | wk1 | wk2 | wk3 | wk4 | wk5 |
|:----:|:-------------------:|:-----------------------:|:----:|:------------:|:---:|:---:|:---:|:---:|:---:|
| 2000 |        2 Pac        | Baby Don't Cry (Keep... | 4:22 |  2000-02-26  | 87  | 82  | 72  | 77  | 87  |
| 2000 |       2Ge+her       | The Hardest Part Of ... | 3:15 |  2000-09-02  | 91  | 87  | 92  | NA  | NA  |
| 2000 |    3 Doors Down     |       Kryptonite        | 3:53 |  2000-04-08  | 81  | 70  | 68  | 67  | 66  |
| 2000 |    3 Doors Down     |          Loser          | 4:24 |  2000-10-21  | 76  | 76  | 72  | 69  | 67  |
| 2000 |      504 Boyz       |      Wobble Wobble      | 3:35 |  2000-04-15  | 57  | 34  | 25  | 17  | 17  |
| 2000 |        98^0         | Give Me Just One Nig... | 3:24 |  2000-08-19  | 51  | 39  | 34  | 26  | 26  |
| 2000 |       A*Teens       |      Dancing Queen      | 3:44 |  2000-07-08  | 97  | 97  | 96  | 95  | 100 |
| 2000 |       Aaliyah       |      I Don't Wanna      | 4:15 |  2000-01-29  | 84  | 62  | 51  | 41  | 38  |
| 2000 |       Aaliyah       |        Try Again        | 4:03 |  2000-03-18  | 59  | 53  | 38  | 28  | 21  |
| 2000 |   Adams, Yolanda    |      Open My Heart      | 5:30 |  2000-08-26  | 76  | 76  | 74  | 69  | 68  |
| 2000 |    Adkins, Trace    |          More           | 3:05 |  2000-04-29  | 84  | 84  | 75  | 73  | 73  |
| 2000 | Aguilera, Christina | Come On Over Baby (A... | 3:38 |  2000-08-05  | 57  | 47  | 45  | 29  | 23  |
]

Week columns continue up to `wk76`!

---
# Billboard

* What are the **observations** in the data?

--

    + Week since entering the Billboard Hot 100 per song
--

* What are the **variables** in the data?
--

    + Year, artist, track, song length, date entered Hot 100, week since first entered Hot 100 (**spread over many columns**), rank during week (**spread over many columns**)
--

* What are the **values** in the data?
--

    + e.g. 2000; 3 Doors Down; Kryptonite; 3 minutes 53 seconds; April 8, 2000; Week 3 (**stuck in column headings**); rank 68 (**spread over many columns**)

---
# Tidy Data

**Tidy data** (aka "long data") are such that:

--

1. The values for a single observation are in their own row.
--

2. The values for a single variable are in their own column.
--

3. The observations are all of the same nature.

--

Why do we want tidy data?

* Easier to understand many rows than many columns
* Required for plotting in `ggplot2`
* Required for many types of statistical procedures (e.g. hierarchical or mixed effects models)
* Fewer confusing variable names
* Fewer issues with missing values and "imbalanced" repeated measures data

---
# `tidyr`

The `tidyr` package provides functions to tidy up data, similar to `reshape` in Stata or `varstocases` in SPSS. Key functions:

--

* **`gather()`**: takes a set of columns and rotates them down to make two new columns (which you can name yourself): 
    * A `key` that stores the original column names
    * A `value` with the values in those original columns

--

* **`spread()`**: inverts `gather()` by taking two columns and rotating them up into multiple columns

--

* **`separate()`**: pulls apart one column into multiple columns (common with `gather`ed data where values had been embedded in column names)
    * `extract_numeric()` does a simple version of this for the common case when you just want grab the number part

--

* **`extract()`** for spreading a column into multiple *sets* of columns.
   * See [Hadley's response to this question](https://stackoverflow.com/questions/25925556/gather-multiple-sets-of-columns) for an example.

---
# `gather()`

Let's use `gather()` to get the week and rank variables out of their current layout into two columns (big increase in rows, big drop in columns):


```r
library(tidyr)
billboard_2000 &lt;- billboard_2000_raw %&gt;%
*   gather(key = week, value = rank, starts_with("wk"))
dim(billboard_2000)
```

```
## [1] 24092     7
```

`starts_with()` and other helper functions from `dplyr::select()` work here too.

We could instead use: `gather(key = week, value = rank, wk1:wk76)` to pull out these contiguous columns.

---
# `gather`ed Weeks

.smallish[

```r
head(billboard_2000)
```

```
## # A tibble: 6 x 7
##    year artist       track                   time  date.entered week   rank
##   &lt;int&gt; &lt;chr&gt;        &lt;chr&gt;                   &lt;chr&gt; &lt;date&gt;       &lt;chr&gt; &lt;int&gt;
## 1  2000 2 Pac        Baby Don't Cry (Keep... 4:22  2000-02-26   wk1      87
## 2  2000 2Ge+her      The Hardest Part Of ... 3:15  2000-09-02   wk1      91
## 3  2000 3 Doors Down Kryptonite              3:53  2000-04-08   wk1      81
## 4  2000 3 Doors Down Loser                   4:24  2000-10-21   wk1      76
## 5  2000 504 Boyz     Wobble Wobble           3:35  2000-04-15   wk1      57
## 6  2000 98^0         Give Me Just One Nig... 3:24  2000-08-19   wk1      51
```
]

Now we have a single week column!

---
# Gathering Better?


```r
summary(billboard_2000$rank)
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.    NA's 
##    1.00   26.00   51.00   51.05   76.00  100.00   18785
```

This is an improvement, but we don't want to keep the 18785 rows with missing ranks (i.e. observations for weeks since entering the Hot 100 that the song was no longer on the Hot 100).

---
# Gathering Better: `na.rm`

The argument `na.rm = TRUE` to `gather()` will remove rows with missing ranks.

```r
billboard_2000 &lt;- billboard_2000_raw %&gt;%
    gather(key = week, value = rank, starts_with("wk"),
*          na.rm = TRUE)
summary(billboard_2000$rank)
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00   26.00   51.00   51.05   76.00  100.00
```

---
# `separate()`

The track length column isn't analytically friendly. Let's convert it to a number rather than the character (minutes:seconds) format:


```r
billboard_2000 &lt;- billboard_2000 %&gt;%
    separate(time, into = c("minutes", "seconds"),
*            sep = ":", convert = TRUE) %&gt;%
    mutate(length = minutes + seconds / 60) %&gt;%
    select(-minutes, -seconds)
summary(billboard_2000$length)
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##   2.600   3.667   3.933   4.031   4.283   7.833
```

`sep = :` tells `separate()` to split the column into two where it finds a colon (`:`).

Then we add `seconds / 60` to `minutes` to produce a numeric `length` in minutes.

---
# `parse_number()`

`tidyr` provides a convenience function to grab just the numeric information from a column that mixes text and numbers:


```r
billboard_2000 &lt;- billboard_2000 %&gt;%
*   mutate(week = parse_number(week))
summary(billboard_2000$week)
```

```
##    Min. 1st Qu.  Median    Mean 3rd Qu.    Max. 
##    1.00    5.00   10.00   11.47   16.00   65.00
```

For more sophisticated conversion or pattern checking, you'll need to use string parsing (to be covered in week 8).

---
# `spread()` Motivation

`spread()` is the opposite of `gather()`, which you use if you have data for the same observation taking up multiple rows.

--

Example of data that we probably want to spread (unless we want to plot each statistic in its own facet):

.small[
| **Group** | **Statistic** | **Value** |
|-------|-----------|------:|
| A     | Mean      |  1.28 |
| A     | Median    |   1.0 |
| A     | SD        |  0.72 |
| B     | Mean      |  2.81 |
| B     | Median    |     2 |
| B     | SD        |  1.33 |
]

A common cue to use `spread()` is having measurements of different quantities in the same column. 

---
# Before `spread()`

.smallish[

```r
(too_long_data &lt;- data.frame(Group = c(rep("A", 3), rep("B", 3)),
                             Statistic = rep(c("Mean", "Median", "SD"), 2),
                             Value = c(1.28, 1.0, 0.72, 2.81, 2, 1.33)))
```

```
##   Group Statistic Value
## 1     A      Mean  1.28
## 2     A    Median  1.00
## 3     A        SD  0.72
## 4     B      Mean  2.81
## 5     B    Median  2.00
## 6     B        SD  1.33
```
]

---
# After `spread()`


```r
(just_right_data &lt;- too_long_data %&gt;%
    spread(key = Statistic, value = Value))
```

```
##   Group Mean Median   SD
## 1     A 1.28      1 0.72
## 2     B 2.81      2 1.33
```

---
# Charts of 2000: Data Prep

Let's look at songs that hit #1 at some point and look how they got there versus songs that did not:


```r
# find best rank for each song
best_rank &lt;- billboard_2000 %&gt;%
    group_by(artist, track) %&gt;%
*   summarize(min_rank = min(rank),
              weeks_at_1 = sum(rank == 1)) %&gt;%
    mutate(`Peak rank` = ifelse(min_rank == 1,
                                "Hit #1",
                                "Didn't #1"))
```

```
## `summarise()` has grouped output by 'artist'. You can override using the `.groups` argument.
```

```r
# merge onto original data
billboard_2000 &lt;- billboard_2000 %&gt;%
    left_join(best_rank, by = c("artist", "track"))
```

.footnote[Note that because the "highest" rank is *numerically lowest* (1), we are summarizing with `min()`.]

---
## Which Were #1 the Most Weeks?


```r
billboard_2000 %&gt;%
    select(artist, track, weeks_at_1) %&gt;%
    distinct(artist, track, weeks_at_1) %&gt;%
    arrange(desc(weeks_at_1)) %&gt;%
    head(7)
```

```
## # A tibble: 7 x 3
##   artist              track                   weeks_at_1
##   &lt;chr&gt;               &lt;chr&gt;                        &lt;int&gt;
## 1 Destiny's Child     Independent Women Pa...         11
## 2 Santana             Maria, Maria                    10
## 3 Aguilera, Christina Come On Over Baby (A...          4
## 4 Madonna             Music                            4
## 5 Savage Garden       I Knew I Loved You               4
## 6 Destiny's Child     Say My Name                      3
## 7 Iglesias, Enrique   Be With You                      3
```

---
# Getting Usable Dates

We have the date the songs first charted, but not the dates for later weeks. We can calculate these now that the data are tidy:


```r
billboard_2000 &lt;- billboard_2000 %&gt;%
*   mutate(date = date.entered + (week - 1) * 7)
billboard_2000 %&gt;% arrange(artist, track, week) %&gt;%
    select(artist, date.entered, week, date, rank) %&gt;% head(4)
```

```
## # A tibble: 4 x 5
##   artist date.entered  week date        rank
##   &lt;chr&gt;  &lt;date&gt;       &lt;dbl&gt; &lt;date&gt;     &lt;int&gt;
## 1 2 Pac  2000-02-26       1 2000-02-26    87
## 2 2 Pac  2000-02-26       2 2000-03-04    82
## 3 2 Pac  2000-02-26       3 2000-03-11    72
## 4 2 Pac  2000-02-26       4 2000-03-18    77
```

This works because `date` objects are in units of days—we just add 7 days per week to the start date.

---
class: inverse
##Joining Data

---
## When Do We Need to Join Data?

* Want to make columns using criteria too complicated for `ifelse()` or `case_when()`

   * We can work with small sets of variables then combine them back together.

* Combine data stored in separate data sets: e.g. UW registrar information with police stop records.

   * Often large surveys are broken into different data sets for each level (e.g. household, individual, neighborhood)

---
## Joining in Concept

We need to think about the following when we want to merge data frames `A` and `B`:

* Which *rows* are we keeping from each data frame?

* Which *columns* are we keeping from each data frame?

* Which variables determine whether rows *match*?

---
## Join Types: Rows and columns kept

There are many types of joins&lt;sup&gt;1&lt;/sup&gt;...

* `A %&gt;% left_join(B)`: keep all rows from `A`, matched with `B` wherever possible (`NA` when not), keep columns from both `A` and `B`

* `A %&gt;% right_join(B)`: keep all rows from `B`, matched with `A` wherever possible (`NA` when not), keep columns from both `A` and `B`

* `A %&gt;% inner_join(B)`: keep only rows from `A` and `B` that match, keep columns from both `A` and `B`

* `A %&gt;% full_join(B)`: keep all rows from both `A` and `B`, matched wherever possible (`NA` when not), keep columns from both `A` and `B`

* `A %&gt;% semi_join(B)`: keep rows from `A` that match rows in `B`, keep columns from only `A`

* `A %&gt;% anti_join(B)`: keep rows from `A` that *don't* match a row in `B`, keep columns from only `A`

.pull-right[.footnote[[1] Usually `left_join()` does the job.]]

---
## Matching Criteria

We say rows should *match* because they have some columns containing the same value. We list these in a `by = ` argument to the join.

Matching Behavior:

* No `by`: Match using all variables in `A` and `B` that have identical names

--

* `by = c("var1", "var2", "var3")`: Match on identical values of `var1`, `var2`, and `var3` in both `A` and `B`

--

* `by = c("Avar1" = "Bvar1", "Avar2" = "Bvar2")`: Match identical values of `Avar1` variable in `A` to `Bvar1` variable in `B`, and `Avar2` variable in `A` to `Bvar2` variable in `B`

Note: If there are multiple matches, you'll get *one row for each possible combination* (except with `semi_join()` and `anti_join()`).

Need to get more complicated? Break it into multiple operations.

---
## `nycflights13` Data

We'll use data in the [`nycflights13` package](https://cran.r-project.org/web/packages/nycflights13/nycflights13.pdf).


```r
library(nycflights13)
```

It includes five dataframes, some of which contain missing data (`NA`):

* `flights`: flights leaving JFK, LGA, or EWR in 2013
* `airlines`: airline abbreviations
* `airports`: airport metadata
* `planes`: airplane metadata
* `weather`: hourly weather data for JFK, LGA, and EWR

Note these are *separate data frames*, each needing to be *loaded separately*:


```r
data(flights)
data(airlines)
data(airports)
# and so on...
```

---
## Join Example

Who manufactures the planes that flew to SeaTac?


```r
flights %&gt;% filter(dest == "SEA") %&gt;% select(tailnum) %&gt;%
*   left_join(planes %&gt;% select(tailnum, manufacturer),
              by = "tailnum") %&gt;%
    count(manufacturer) %&gt;% # Count observations by manufacturer
    arrange(desc(n)) # Arrange data descending by count
```

```
## # A tibble: 6 x 2
##   manufacturer           n
##   &lt;chr&gt;              &lt;int&gt;
## 1 BOEING              2659
## 2 AIRBUS               475
## 3 AIRBUS INDUSTRIE     394
## 4 &lt;NA&gt;                 391
## 5 BARKER JACK L          2
## 6 CIRRUS DESIGN CORP     2
```

Note you can perform operations on the data inside functions such as `left_join()` and the *output* will be used by the function.

---
# Visualization Preview

The next workshop will focus on visualization using `ggplot2`.

We could visualize the data we worked with today to understand it better.

---
# Charts of 2000: `ggplot2`


```r
library(ggplot2)
billboard_trajectories &lt;- 
  ggplot(data = billboard_2000,
         aes(x = week, y = rank, group = track,
             color = `Peak rank`)
         ) +
  geom_line(aes(size = `Peak rank`), alpha = 0.4) +
    # rescale time: early weeks more important
  scale_x_log10(breaks = seq(0, 70, 10)) + 
  scale_y_reverse() + # want rank 1 on top, not bottom
  theme_classic() +
  xlab("Week") + ylab("Rank") +
  scale_color_manual("Peak Rank", values = c("black", "red")) +
  scale_size_manual("Peak Rank", values = c(0.25, 1)) +
  theme(legend.position = c(0.90, 0.25),
        legend.background = element_rect(fill="transparent"))
```

---
# Charts of 2000: Beauty!

![](Aula2_Tidyverse_files/figure-html/unnamed-chunk-48-1.svg)&lt;!-- --&gt;

Observation: There appears to be censoring around week 20 for songs falling out of the top 50 that I'd want to follow up on.

---
# Resources

   * [UW CSSS508](https://clanfear.github.io/CSSS508/): My University of Washington Introduction to R course which forms the basis for this workshop. All content including lecture videos is freely available.
   * [R for Data Science](http://r4ds.had.co.nz/) online textbook by Garrett Grolemund and Hadley Wickham. One of many good R texts available, but importantly it is free and focuses on the [`tidyverse`](http://tidyverse.org/) collection of R packages which are the modern standard for data manipulation and visualization in R.
   * [Advanced R](http://adv-r.had.co.nz/) online textbook by Hadley Wickham. A great source for more in-depth and advanced R programming.
   * [DataCamp](https://www.datacamp.com/): A source for interactive R tutorials (some free of charge).
   * [`swirl`](http://swirlstats.com/students.html): Interactive tutorials inside R.
   * [Useful RStudio cheatsheets](https://www.rstudio.com/resources/cheatsheets/) on R Markdown, RStudio shortcuts, etc.
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "tomorrow-night-bright",
"highlightLines": true,
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
